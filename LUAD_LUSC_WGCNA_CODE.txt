
########Code describes a workflow based WGCNA tutorial available at https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/index.html
########Please see references supplied in the readme document 


#############################################DATA SET LIMITATION TO LUAD / LUSC



cd /rds/general/project/nhli-lungen-asthma/live/Saffron/EXPRESSION/CANCER2019/

R

####################Load data

load("CANCER2019medbio_296samples_RMA_18717TC_PREPROCESSED_DATA.R")
##The rma-treated, filtered expression data for analysis are in edata.Fil2


p<-read.csv("Pheno.csv",header=T,row.names=1)
pheno<-p[colnames(edata.Fil2),]
table(rownames(pheno)==colnames(edata.Fil2))
#TRUE 
# 296 


####################Select LUAD (histology 1) / LUSC (histology 5)

keep<-as.character(rownames(pheno[which(pheno$histology==1 | pheno$histology==5),]))

table(pheno[keep,"histology"])
#  1   5 
#175  62 

in_exp<-edata.Fil2[,keep]
in_p<-pheno[keep,]

table(as.character(rownames(in_p))==as.character(colnames(in_exp)))
#TRUE 
# 237 


rm(keep,p)

save(list=ls(),file="ADEvsSQonly/ADEvsSQconsensus_analysis.R")

##Expression data limited to LUAD and LUSC histologies are now located in in_exp
##Matching phenotypic data are now in in_p


#############################################WGCNA: PREPARE DATA

library(ggplot2)
library(gridExtra)
library(WGCNA)

allowWGCNAThreads();
options(stringsAsFactors = FALSE);

##Prefix transcript cluster IDs with "TC" and rotate orientation
in_expT<-in_exp
rownames(in_expT)<-paste("TC",rownames(in_expT),sep="")
in_expT<-t(in_expT)

table(as.character(rownames(in_p))==as.character(rownames(in_expT)))
#TRUE 
# 237 




####################Define binary histology variables within in_p from the categorical histology variable

in_p$Adenocarcinoma<-ifelse(in_p$histology=="1", "1","0")
in_p$SCC<-ifelse(in_p$histology=="5", "1","0")



####################Segregate tumour and histologically normal samples and create multi-set structure to hold expression data


indexT <- which(in_p$dx_status=="1")
Tsamples<-as.character(rownames(in_p))[indexT]
table(in_p[Tsamples,"dx_status"])
#  1 
#124 

datEXP_T<-in_expT[Tsamples,]
datP_T<-in_p[Tsamples,]
table(datP_T$dx_status)
#  1 
#124 


indexN <- which(in_p$dx_status=="0")
Nsamples<-as.character(rownames(in_p))[indexN]
table(in_p[Nsamples,"dx_status"])
#  0 
#113 

datEXP_N<-in_expT[Nsamples,]
datP_N<-in_p[Nsamples,]
table(datP_N$dx_status)
#  0 
#113 


table(as.character(row.names(datP_N))==as.character(row.names(datEXP_N)))
#TRUE 
# 113 


table(as.character(row.names(datP_T))==as.character(row.names(datEXP_T)))
#TRUE 
# 124 



nSets = 2;
setLabels = c("Tumour tissue", "Healthy tissue")
shortLabels = c("Tumour", "Healthy")

multiExpr = vector(mode = "list", length = nSets)

multiExpr[[1]] = list(data = as.data.frame(datEXP_T));
multiExpr[[2]] = list(data = as.data.frame(datEXP_N));



####################Checking data format and quality, loading phenotypic data
exprSize = checkSets(multiExpr)
exprSize

#$nSets
#[1] 2
#
#$nGenes
#[1] 18717
#
#$nSamples
#[1] 124 113
#
#$structureOK
#[1] TRUE


gsg = goodSamplesGenesMS(multiExpr, verbose = 3);
# Flagging genes and samples with too many missing values...
#  ..step 1
#   ..bad gene count: 0, bad sample counts: 0, 0


gsg$allOK
#[1] TRUE




##Check sample clustering in each of the two datasets

sampleTrees = list()
for (set in 1:nSets)
{
  sampleTrees[[set]] = hclust(dist(multiExpr[[set]]$data), method = "average")
}


pdf(file = "ADEvsSQonly/SampleClustering.pdf", width = 16, height = 12);
par(mfrow=c(2,1))
par(mar = c(0, 4, 2, 0))
for (set in 1:nSets)
  plot(sampleTrees[[set]], main = paste("Sample clustering on all genes in", setLabels[set]),
      xlab="", sub="", cex = 0.7);
dev.off();


## Load selected phenotypic data

pheno2<-in_p[,c(4,6,7,8,10,11,12, 13, 15, 16, 17, 18, 23, 29, 30, 31,42,43)]



## Form a multi-set structure that will hold these phenotypes.
Traits = vector(mode="list", length = nSets);
for (set in 1:nSets)
{
  setSamples = rownames(multiExpr[[set]]$data);
  traitRows = match(setSamples, as.character(rownames(pheno2)));
  Traits[[set]] = list(data = pheno2[traitRows,]);
}


table(Traits[[2]]$data$dx_status)
#  0 
#113 

table(Traits[[1]]$data$dx_status)
#  1 
#124 

collectGarbage();
## Define data set dimensions
nGenes = exprSize$nGenes;
nSamples = exprSize$nSamples;


save(multiExpr, Traits, nGenes, nSamples, setLabels, shortLabels, exprSize, 
     file = "ADEvsSQonly/Consensus-dataInput.RData");

#############################################WGCNA: SOFT THRESHOLDING POWER SELECTION


## List the soft-thresholding powers to check
powers = c(seq(1,10,by=1), seq(12,20, by=2));
powerTables = vector(mode = "list", length = nSets);


## Call the network topology analysis function for each of the two datasets

for (set in 1:nSets)
  powerTables[[set]] = list(data = pickSoftThreshold(multiExpr[[set]]$data, powerVector=powers,
                                                     verbose = 2,blockSize=20000)[[2]]);

# pickSoftThreshold: calculating connectivity for given powers...
#   ..working on genes 1 through 18717 of 18717
#   Power SFT.R.sq  slope truncated.R.sq  mean.k. median.k. max.k.
#1      1  0.00288 -0.212          0.933 2.44e+03  2.36e+03 4440.0
#2      2  0.56700 -1.970          0.973 5.19e+02  4.58e+02 1640.0
#3      3  0.79300 -2.440          0.974 1.47e+02  1.12e+02  761.0
#4      4  0.87300 -2.380          0.988 5.08e+01  3.23e+01  408.0
#5      5  0.87300 -2.300          0.978 2.07e+01  1.05e+01  243.0
#6      6  0.89400 -2.130          0.983 9.58e+00  3.77e+00  157.0
#7      7  0.90800 -1.980          0.985 4.96e+00  1.48e+00  110.0
#8      8  0.91400 -1.880          0.983 2.81e+00  6.23e-01   81.7
#9      9  0.92300 -1.770          0.984 1.72e+00  2.78e-01   63.4
#10    10  0.91500 -1.710          0.978 1.12e+00  1.31e-01   50.8
#11    12  0.92800 -1.600          0.987 5.49e-01  3.26e-02   35.4
#12    14  0.92200 -1.550          0.978 3.08e-01  9.16e-03   26.3
#13    16  0.93100 -1.500          0.986 1.89e-01  2.74e-03   20.3
#14    18  0.90300 -1.490          0.961 1.24e-01  8.83e-04   16.0
#15    20  0.91300 -1.460          0.967 8.48e-02  2.91e-04   12.8



#   Power SFT.R.sq  slope truncated.R.sq  mean.k. median.k. max.k.
#1      1  0.00729 -0.357          0.929 2740.000  2.69e+03 4790.0
#2      2  0.42800 -1.700          0.961  656.000  6.09e+02 1870.0
#3      3  0.73000 -2.210          0.983  207.000  1.74e+02  933.0
#4      4  0.82900 -2.370          0.989   78.800  5.79e+01  530.0
#5      5  0.87300 -2.330          0.992   34.600  2.16e+01  327.0
#6      6  0.87800 -2.190          0.966   17.100  8.81e+00  214.0
#7      7  0.96300 -1.820          0.976    9.310  3.84e+00  146.0
#8      8  0.99000 -1.700          0.990    5.490  1.76e+00  122.0
#9      9  0.99000 -1.630          0.987    3.480  8.40e-01  110.0
#10    10  0.98300 -1.550          0.979    2.340  4.17e-01   99.9
#11    12  0.97900 -1.400          0.980    1.230  1.11e-01   83.9
#12    14  0.97200 -1.300          0.976    0.752  3.23e-02   71.7
#13    16  0.97600 -1.220          0.981    0.509  1.02e-02   62.0
#14    18  0.97000 -1.180          0.972    0.368  3.38e-03   54.1
#15    20  0.97600 -1.140          0.978    0.280  1.15e-03   47.5



collectGarbage();

## Plot the results of the network topology analysis function
colors = c("black", "red")
plotCols = c(2,5,6,7)
colNames = c("Scale Free Topology Model Fit", "Mean connectivity", "Median connectivity",
"Max connectivity");
ylim = matrix(NA, nrow = 2, ncol = 4);
for (set in 1:nSets)
{
  for (col in 1:length(plotCols))
  {
    ylim[1, col] = min(ylim[1, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE);
    ylim[2, col] = max(ylim[2, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE);
  }
}


pdf(file = "ADEvsSQonly/AnalysisOfNetworkTopology.pdf", width = 8, height = 6);
par(mfcol = c(2,2));
par(mar = c(4.2, 4.2 , 2.2, 0.5))
cex1 = 0.7;
for (col in 1:length(plotCols)) for (set in 1:nSets)
{
  if (set==1)
  {
    plot(powerTables[[set]]$data[,1], -sign(powerTables[[set]]$data[,3])*powerTables[[set]]$data[,2],
         xlab="Soft Threshold (power)",ylab=colNames[col],type="n", ylim = ylim[, col],
         main = colNames[col]);
    addGrid();
  }
  if (col==1)
  {
    text(powerTables[[set]]$data[,1], -sign(powerTables[[set]]$data[,3])*powerTables[[set]]$data[,2],
         labels=powers,cex=cex1,col=colors[set]);
  } else
    text(powerTables[[set]]$data[,1], powerTables[[set]]$data[,plotCols[col]],
         labels=powers,cex=cex1,col=colors[set]);
  if (col==1)
  {
    legend("bottomright", legend = setLabels, col = colors, pch = 20) ;
  } else
    legend("topright", legend = setLabels, col = colors, pch = 20) ;
}
dev.off()




##Report model fit stats for set 1 (T) rounded to 1 dp
round(-sign(powerTables[[1]]$data[,3])*powerTables[[1]]$data[,2],1)
#[1] 0.0 0.6 0.8 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9


##Report model fit stats for set 2 (N) rounded to 1 dp
round(-sign(powerTables[[2]]$data[,3])*powerTables[[2]]$data[,2],1)

# [1] 0.0 0.4 0.7 0.8 0.9 0.9 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0


##Set 1 (T) first meets scale free topology model fit 0.9 at a power of 4 
##Set 2 (N) first exceeds scale free topology model fit 0.9 at a power of 5 
## A power of 5 selected for both data sets


save(list=ls(),file="ADEvsSQonly/ADEvsSQconsensus_analysis.R")




#############################################WGCNA: NETWORK ADJACENCIES, TOM AND SCALING

####################Adjacencies

softPower = 5;
adjacencies = array(0, dim = c(nSets, nGenes, nGenes));

for (set in 1:nSets)
  adjacencies[set, , ] = abs(cor(multiExpr[[set]]$data, use = "p"))^softPower;




save(list=ls(),file="ADEvsSQonly/ADEvsSQconsensus_analysis.R")


####################TOM


TOM = array(0, dim = c(nSets, nGenes, nGenes));
for (set in 1:nSets)
  TOM[set, , ] = TOMsimilarity(adjacencies[set, , ]);
#..connectivity..
#..matrix multiplication..
#..normalization..
#..done.
#..connectivity..
#..matrix multiplication..
#..normalization..
#..done.


####################Scaling

scaleP = 0.95
set.seed(12345)
nSamples = as.integer(1/(1-scaleP) * 1000);
scaleSample = sample(nGenes*(nGenes-1)/2, size = nSamples)
TOMScalingSamples = list();
scaleQuant = rep(1, nSets)
scalePowers = rep(1, nSets)
# Loop over sets
for (set in 1:nSets)
{
  # Select the sampled TOM entries
  TOMScalingSamples[[set]] = as.dist(TOM[set, , ])[scaleSample]
  # Calculate the 95th percentile
  scaleQuant[set] = quantile(TOMScalingSamples[[set]],
                             probs = scaleP, type = 8);
  # Scale the N (set 2) TOM
  if (set>1)
  {
    scalePowers[set] = log(scaleQuant[1])/log(scaleQuant[set]);
    TOM[set, ,] = TOM[set, ,]^scalePowers[set];
  }
}



## For plotting, also scale the sampled TOM entries
scaledTOMSamples = list();
for (set in 1:nSets)
  scaledTOMSamples[[set]] = TOMScalingSamples[[set]]^scalePowers[set]

pdf(file = "ADEvsSQonly/TOMScaling-QQPlot.pdf", width = 6, height = 6);
## qq plot of the unscaled samples
qqUnscaled = qqplot(TOMScalingSamples[[1]], TOMScalingSamples[[2]], plot.it = TRUE, cex = 0.6,
                    xlab = paste("TOM in", setLabels[1]), ylab = paste("TOM in", setLabels[2]),
                    main = "Q-Q plot of TOM", pch = 20)
## qq plot of the scaled samples
qqScaled = qqplot(scaledTOMSamples[[1]], scaledTOMSamples[[2]], plot.it = FALSE)
points(qqScaled$x, qqScaled$y, col = "red", cex = 0.6, pch = 20);
abline(a=0, b=1, col = "blue")
legend("topleft", legend = c("Unscaled TOM", "Scaled TOM"), pch = 20, col = c("black", "red"))
dev.off();


####################Consensus TOM
consensusTOM = pmin(TOM[1, , ], TOM[2, , ]);


#############################################WGCNA: Hierarchical clustering and network identification
consTree = hclust(as.dist(1-consensusTOM), method = "average");
minModuleSize = 30;
unmergedLabels = cutreeDynamic(dendro = consTree, distM = 1-consensusTOM,
                deepSplit = 2, cutHeight = 0.995,
                minClusterSize = minModuleSize,
                pamRespectsDendro = FALSE );
unmergedColors = labels2colors(unmergedLabels)



pdf(file = "ADEvsSQonly/Consensus_dendrogram.pdf", width = 8, height = 6);
plotDendroAndColors(consTree, unmergedColors, "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
dev.off()



unmergedMEs = multiSetMEs(multiExpr, colors = NULL, universalColors = unmergedColors)
consMEDiss = consensusMEDissimilarity(unmergedMEs);
consMETree = hclust(as.dist(consMEDiss), method = "average");

pdf(file = "ADEvsSQonly/Consensus_clustering_of_module_eigengenes.pdf", width = 14, height = 6);
par(mfrow = c(1,1))
plot(consMETree, main = "Consensus clustering of consensus module eigengenes",
     xlab = "", sub = "")
abline(h=0.25, col = "red")
dev.off()


merge = mergeCloseModules(multiExpr, unmergedLabels, cutHeight = 0.25, verbose = 3)

moduleLabels = merge$colors;
moduleColors = labels2colors(moduleLabels)
consMEs = merge$newMEs;


pdf(file = "ADEvsSQonly/Consensus_dendrogram_after_merging_modules.pdf", width = 14, height = 6);
plotDendroAndColors(consTree, cbind(unmergedColors, moduleColors),
                    c("Unmerged", "Merged"),
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)

dev.off()

table(moduleColors)
#moduleColors
#        bisque4           black            blue           brown          brown4 
#             54             371             735             486              57 
#           cyan       darkgreen     darkmagenta  darkolivegreen      darkorange 
#            262             195             113             120             242 
#        darkred   darkslateblue   darkturquoise     floralwhite           green 
#            202              41             194              67             714 
#    greenyellow            grey          grey60           ivory       lightcyan 
#            350            8129             240              70             254 
#     lightcyan1      lightgreen lightsteelblue1     lightyellow         magenta 
#             71             236              88             385             298 
#         orange      orangered4   paleturquoise            pink           plum1 
#            151              95             122             346             105 
#          plum2          purple             red       royalblue     saddlebrown 
#             40             395             419             215             139 
#         salmon         sienna3         skyblue        skyblue3       steelblue 
#            267             112             141             106             130 
#            tan        thistle1        thistle2       turquoise          violet 
#            269              35              40             881             121 
#          white          yellow 
#            151             463 


save(consMEs, moduleColors, moduleLabels, consTree, file = "ADEvsSQonly/Consensus-NetworkConstruction-man.RData")





#######################WGCNA: comparing consensus eigengene networks in T and N tissues


survival = vector(mode = "list", length = nSets);
for (set in 1:nSets)
{
  survival[[set]] = list(data = as.data.frame(Traits[[set]]$data$mths_survival_till_death));
  names(survival[[set]]$data) = "Survival"
}
consMEsC = multiSetMEs(multiExpr, universalColors = moduleColors);
MET = consensusOrderMEs(addTraitToMEs(consMEsC, survival));



pdf(file = "ADEvsSQonly/EigengeneNetworks.pdf", width = 16, height = 10);
par(cex = 0.5)
plotEigengeneNetworks(MET,setLabels, marDendro = c(0,2,2,1), marHeatmap = c(5,3,2,1),
                      zlimPreservation = c(0, 1), xLabelsAngle = 90)
dev.off();



save(list=ls(),file="ADEvsSQonly/ADEvsSQconsensus_analysis.R")



#######################WGCNA: relating consensus modules to external microarray sample information

moduleTraitCor = list();
moduleTraitPvalue = list();
for (set in 1:nSets)
{
  moduleTraitCor[[set]] = cor(consMEs[[set]]$data, Traits[[set]]$data, use = "p");
  moduleTraitPvalue[[set]] = corPvalueFisher(moduleTraitCor[[set]], exprSize$nSamples[set]);
}


MEColors = labels2colors(as.numeric(substring(names(consMEs[[1]]$data), 3)));
MEColorNames = paste("ME", MEColors, sep="");





C_XLABELS<-c("Lymph Invasion", "Vasculature Invasion", "Pleural Invasion","Cancer Stage","Degree of Pleural Involvement","Gender","Age (years)","PYH","BMI","FEV1","FVC","Survival (months)","Asbestos Exposure","Performance Status","History of Cancer","LUAD","LUSC")

cbind(names(Traits[[set]]$data[-1]),C_XLABELS)

#                                 C_XLABELS                      
# [1,] "lymph_invasion"           "Lymph Invasion"               
# [2,] "AN_vascinvasion"          "Vasculature Invasion"         
# [3,] "pleural_invasion"         "Pleural Invasion"             
# [4,] "stage_x"                  "Cancer Stage"                 
# [5,] "pleural_stage"            "Degree of Pleural Involvement"
# [6,] "gender"                   "Gender"                       
# [7,] "age_op"                   "Age (years)"                  
# [8,] "PYH"                      "PYH"                          
# [9,] "BMI"                      "BMI"                          
#[10,] "FEV1"                     "FEV1"                         
#[11,] "FVC"                      "FVC"                          
#[12,] "mths_survival_till_death" "Survival (months)"            
#[13,] "asbestos_exposure"        "Asbestos Exposure"            
#[14,] "PS"                       "Performance Status"           
#[15,] "PMHx_Ca"                  "History of Cancer"            
#[16,] "Adenocarcinoma"           "LUAD"                         
#[17,] "SCC"                      "LUSC"                        

## Plot the module-trait relationship table for set number 1

pdf(file = "ADEvsSQonly/ModuleTraitRelationships-set1_TUMOUR.pdf", wi = 15, he = 20);
set = 1
textMatrix =  paste(signif(moduleTraitCor[[set]][,-1], 2), "\n(",
                           signif(moduleTraitPvalue[[set]][,-1], 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor[[set]][,-1])
par(mar = c(8, 11, 3, 2.2));
labeledHeatmap(Matrix = moduleTraitCor[[set]][,-1],
               xLabels = C_XLABELS,
               yLabels = MEColorNames,
               ySymbols = MEColorNames,
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module--trait relationships in", setLabels[set]))
dev.off();



## Plot the module-trait relationship table for set number 2

pdf(file = "ADEvsSQonly/ModuleTraitRelationships-set2_NORMAL.pdf", wi = 15, he = 20);
set = 2
textMatrix =  paste(signif(moduleTraitCor[[set]][,-1], 2), "\n(",
                           signif(moduleTraitPvalue[[set]][,-1], 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor[[set]][,-1])
par(mar = c(8, 11, 3, 2.2));
labeledHeatmap(Matrix = moduleTraitCor[[set]][,-1],
               xLabels = C_XLABELS,
               yLabels = MEColorNames,
               ySymbols = MEColorNames,
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module--trait relationships in", setLabels[set]))
dev.off();



save(list=ls(),file="ADEvsSQonly/ADEvsSQconsensus_analysis.R")




#######################WGCNA:Export consensus results

table(rownames(moduleTraitCor[[1]])==rownames(moduleTraitCor[[2]]))
consensus_key<-cbind(rownames(moduleTraitCor[[1]]),MEColorNames)

write.table(consensus_key, file="ADEvsSQonly/Consensus_module_key.txt",sep="\t")


##Load Affymetrix annotation information.


annot <- read.table("/rds/general/project/nhli-lungen-asthma/live/Saffron/EXPRESSION/ANNOTATION/HuGene-1_1-st-v1/HuGene-1_1-st-v1.na36.hg19.transcript.csv",sep=",",header=T)



annot_3<-annot
annot_3$TCID<-paste("TC",annot_3$transcript_cluster_id,sep="")

# Match probes in the data set to the probe IDs in the annotation file 
probes = names(multiExpr[[1]]$data)
probes2annot = match(probes, annot_3$TCID)



consMEs.unord = multiSetMEs(multiExpr, universalColors = moduleLabels, excludeGrey = TRUE)
GS = list();
kME = list();
for (set in 1:nSets)
{
  GS[[set]] = corAndPvalue(multiExpr[[set]]$data, Traits[[set]]$data);
  kME[[set]] = corAndPvalue(multiExpr[[set]]$data, consMEs.unord[[set]]$data);
}


GS.metaZ = (GS[[1]]$Z + GS[[2]]$Z)/sqrt(2);
kME.metaZ = (kME[[1]]$Z + kME[[2]]$Z)/sqrt(2);
GS.metaP = 2*pnorm(abs(GS.metaZ), lower.tail = FALSE);
kME.metaP = 2*pnorm(abs(kME.metaZ), lower.tail = FALSE);


GSmat = rbind(GS[[1]]$cor, GS[[2]]$cor, GS[[1]]$p, GS[[2]]$p, GS.metaZ, GS.metaP);
nTraits = checkSets(Traits)$nGenes
traitNames = colnames(Traits[[1]]$data)
dim(GSmat) = c(nGenes, 6*nTraits)
rownames(GSmat) = probes;
colnames(GSmat) = spaste(
    c("GS.set1.", "GS.set2.", "p.GS.set1.", "p.GS.set2.", "Z.GS.meta.", "p.GS.meta"),
    rep(traitNames, rep(6, nTraits)))


kMEmat = rbind(kME[[1]]$cor, kME[[2]]$cor, kME[[1]]$p, kME[[2]]$p, kME.metaZ, kME.metaP);
MEnames = colnames(consMEs.unord[[1]]$data);
nMEs = checkSets(consMEs.unord)$nGenes
dim(kMEmat) = c(nGenes, 6*nMEs)
rownames(kMEmat) = probes;
colnames(kMEmat) = spaste(
    c("kME.set1.", "kME.set2.", "p.kME.set1.", "p.kME.set2.", "Z.kME.meta.", "p.kME.meta"),
    rep(MEnames, rep(6, nMEs)))



info = data.frame(Probe = probes, GeneAssignment = annot_3$gene_assignment[probes2annot],mRNAassignment=annot_3$mrna_assignment[probes2annot],
             Chr = annot_3$seqname[probes2annot],
             ModuleLabel = moduleLabels,
             ModuleColor = labels2colors(moduleLabels),
             GSmat,
             kMEmat);
write.csv(info, file = "ADEvsSQonly/consensusAnalysis-CombinedNetworkResults.csv",
          row.names = FALSE, quote = TRUE);


save(list=ls(),file="ADEvsSQonly/ADEvsSQconsensus_analysis.R")




#############################################WGCNA: Tumour only
##In a new terminal


module load legacy_lungen_modules
module load R

cd /rds/general/project/nhli-lungen-asthma/live/Saffron/EXPRESSION/CANCER2019/

R


library(ggplot2)
library(gridExtra)
library(WGCNA)

allowWGCNAThreads();
options(stringsAsFactors = FALSE);

load("ADEvsSQonly/Consensus-dataInput.RData")

#######################Specify tumour data


TdatExpr<-multiExpr[[1]]$data
TdatTraits<-Traits[[1]]$data

table(rownames(TdatExpr)==rownames(TdatTraits))
#TRUE 
# 124 



rm(exprSize,multiExpr,nGenes,nSamples,setLabels,shortLabels,Traits)

#######################Tumour: Soft thresholding


softPower = 5;
adjacency = adjacency(TdatExpr, power = softPower);
#######################Tumour: TOM
TOM = TOMsimilarity(adjacency);
#..connectivity..
#..matrix multiplication..
#..normalization..
#..done.


dissTOM = 1-TOM



#############################################Tumour: Hierarchical clustering and network identification
geneTree = hclust(as.dist(dissTOM), method = "average");

pdf(file = "ADEvsSQonly/Tumour_only_manual/T_SampleClustering.pdf", width = 16, height = 12);
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity - Tumour only",
     labels = FALSE, hang = 0.04);
dev.off()


minModuleSize = 30;
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
                deepSplit = 2, cutHeight = 0.995, pamRespectsDendro = FALSE,
                minClusterSize = minModuleSize);
table(dynamicMods)

#dynamicMods
#   0    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15 
#2213 2220 1970 1861 1464 1284  888  777  738  583  416  401  354  343  267  251 
#  16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31 
# 240  213  207  164  162  138  124  116  112  111  107  103  103   90   87   77 
#  32   33   34   35   36   37   38   39   40   41 
#  72   65   62   58   57   55   45   44   42   33 

dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)
#dynamicColors
#          black            blue           brown            cyan       darkgreen 
#            777            1970            1861             267             124 
#       darkgrey     darkmagenta  darkolivegreen      darkorange         darkred 
#            112              62              65             107             138 
#  darkturquoise           green     greenyellow            grey          grey60 
#            116            1284             401            2213             213 
#      lightcyan      lightgreen lightsteelblue1     lightyellow         magenta 
#            240             207              33             164             583 
#  mediumpurple3    midnightblue          orange      orangered4   paleturquoise 
#             42             251             111              44              77 
#           pink           plum1          purple             red       royalblue 
#            738              45             416             888             162 
#    saddlebrown          salmon         sienna3         skyblue        skyblue3 
#             90             343              58             103              55 
#      steelblue             tan       turquoise          violet           white 
#             87             354            2220              72             103 
#         yellow     yellowgreen 
#           1464              57 


pdf(file = "ADEvsSQonly/Tumour_only_manual/Tonly_dendrogram.pdf", width = 8, height = 6);

plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colours")
dev.off()


MEList = moduleEigengenes(TdatExpr, colors = dynamicColors)
MEs = MEList$eigengenes
MEDiss = 1-cor(MEs);
METree = hclust(as.dist(MEDiss), method = "average");

pdf(file = "ADEvsSQonly/Tumour_only_manual/Tonly_clustering_of_module_eigengenes.pdf", width = 14, height = 6);
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")
dev.off()


MEDissThres = 0.25

pdf(file = "ADEvsSQonly/Tumour_only_manual/Tonly_clustering_of_module_eigengenes_with_cutline.pdf", width = 14, height = 6);
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")+abline(h=MEDissThres, col = "red")
dev.off()

merge = mergeCloseModules(TdatExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)

# mergeCloseModules: Merging modules whose distance is less than 0.25
#   multiSetMEs: Calculating module MEs.
#     Working on set 1 ...
#     moduleEigengenes: Calculating 42 module eigengenes in given set.
#   multiSetMEs: Calculating module MEs.
#     Working on set 1 ...
#     moduleEigengenes: Calculating 38 module eigengenes in given set.
#   multiSetMEs: Calculating module MEs.
#     Working on set 1 ...
#     moduleEigengenes: Calculating 37 module eigengenes in given set.
#   Calculating new MEs...
#   multiSetMEs: Calculating module MEs.
#     Working on set 1 ...
#     moduleEigengenes: Calculating 37 module eigengenes in given set.

mergedColors = merge$colors;
mergedMEs = merge$newMEs;



pdf(file = "ADEvsSQonly/Tumour_only_manual/Tonly_dendrogram_after_merging_modules.pdf", width = 14, height = 6);

plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
dev.off()


moduleColors = mergedColors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;


##Rename to avoid overlap

TUMOURMEs<-MEs
TUMOURmoduleLabels<-moduleLabels
TUMOURmoduleColors<-moduleColors
TUMOURgeneTree<-geneTree





## Save module colors and labels for subsequent use 
save(TUMOURMEs, TUMOURmoduleLabels, TUMOURmoduleColors, TUMOURgeneTree, file = "ADEvsSQonly/Tumour_only_manual/Tonly-networkConstruction-stepByStep.RData")


#######################Tumour: Relating tumour-only modules to external trait information
TdatTraits2<-TdatTraits[,c(2,3,4,5,6,7,8,9,10,11,17,18)]
C_XLABELS2<-c("Lymph Invasion", "Vasculature Invasion", "Pleural Invasion","Cancer Stage","Degree of Pleural Involvement","Sex","Age (years)","PYH","BMI","FEV1","LUAD","LUSC")

cbind(names(TdatTraits2),C_XLABELS2)
#                         C_XLABELS2                     
# [1,] "lymph_invasion"   "Lymph Invasion"               
# [2,] "AN_vascinvasion"  "Vasculature Invasion"         
# [3,] "pleural_invasion" "Pleural Invasion"             
# [4,] "stage_x"          "Cancer Stage"                 
# [5,] "pleural_stage"    "Degree of Pleural Involvement"
# [6,] "gender"           "Sex"                          
# [7,] "age_op"           "Age (years)"                  
# [8,] "PYH"              "PYH"                          
# [9,] "BMI"              "BMI"                          
#[10,] "FEV1"             "FEV1"                         
#[11,] "Adenocarcinoma"   "LUAD"                         
#[12,] "SCC"              "LUSC"            


#######Reassign invasion phenotypes for directionality
#Historically 1==YES, 2==NO
#Recoded to 0==NO, 1==YES

TdatTraits2$lymph_invasion<-gsub("2","0", TdatTraits2$lymph_invasion)
TdatTraits2$pleural_invasion<-gsub("2","0", TdatTraits2$pleural_invasion)
TdatTraits2$AN_vascinvasion<-gsub("2","0", TdatTraits2$AN_vascinvasion)




##Relate Tonly modules to clinical traits

# Define numbers of genes and samples
nGenes = ncol(TdatExpr);
nSamples = nrow(TdatExpr);
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(TdatExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)


TestBicor = bicorAndPvalue(MEs, TdatTraits2, use = "p", alternative="two.sided",robustY=FALSE, maxPOutliers=0.05);


BI_Pval<-TestBicor$p
BI_Cor<-TestBicor$bicor
BI_nObs<-TestBicor$nObs
BI_t<-TestBicor$t
BI_Z<-TestBicor$Z





#Plot results
pdf(file = "ADEvsSQonly/Tumour_only_manual/Tonly_ModuleTraitRelationships_BICOR_InvasionPhenosRecoded.pdf", wi = 10, he = 12);
textMatrix =  paste(signif(BI_Cor, 2), "\n(",
                           signif(BI_Pval, 1), ")", sep = "");
dim(textMatrix) = dim(BI_Cor)
par(mar = c(9, 11, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = BI_Cor,
               xLabels = C_XLABELS2,
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in tumour samples"))


dev.off()





survival = as.data.frame(TdatTraits$mths_survival_till_death);
names(survival) = "Survival"
modNames = substring(names(MEs), 3)

geneModuleMembership = as.data.frame(cor(TdatExpr, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));

names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");

geneTraitSignificance = as.data.frame(cor(TdatExpr, survival, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));

names(geneTraitSignificance) = paste("GS.", names(survival), sep="");
names(GSPvalue) = paste("p.GS.", names(survival), sep="");


annotTC <- read.table("/rds/general/project/nhli-lungen-asthma/live/Saffron/EXPRESSION/ANNOTATION/HuGene-1_1-st-v1/HuGene-1_1-st-v1.na36.hg19.transcript.csv",sep=",",header=T)
dim(annotTC)

annotTC$TCID<-paste("TC",annotTC$transcript_cluster_id,sep="")
probes = names(TdatExpr)
probes2annot = match(probes, annotTC$TCID)
## The following is the number or probes without annotation:
sum(is.na(probes2annot))
#[1] 0



geneInfo0 = data.frame(Probe = probes,
                       GeneAssignment = annotTC$gene_assignment[probes2annot],
                       mRNAassignment=annotTC$mrna_assignment[probes2annot],
                       Chr = annotTC$seqname[probes2annot],
                       moduleColor = moduleColors,
                       geneTraitSignificance,
                       GSPvalue)
modOrder = order(-abs(cor(MEs, survival, use = "p")));
for (mod in 1:ncol(geneModuleMembership))
{
  oldNames = names(geneInfo0)
  geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]], 
                         MMPvalue[, modOrder[mod]]);
  names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
                       paste("p.MM.", modNames[modOrder[mod]], sep=""))
}
# Order the genes in the geneInfo variable first by module colour, then by geneTraitSignificance
geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.Survival));
geneInfo = geneInfo0[geneOrder, ]


write.csv(geneInfo, file = "ADEvsSQonly/Tumour_only_manual/Tonly_geneInfo.csv",quote=TRUE)



save(list=ls(),file="ADEvsSQonly/Tumour_only_manual/Tumour_only_manual_WGCNA_analysis.Rdata")

table(moduleColors)

#moduleColors
#           blue           brown            cyan       darkgreen        darkgrey 
#           1970            1861             267             124             112 
#    darkmagenta  darkolivegreen      darkorange         darkred   darkturquoise 
#             62              65             107             138             116 
#          green     greenyellow            grey          grey60       lightcyan 
#           1284             401            2213             213            1268 
#     lightgreen lightsteelblue1     lightyellow         magenta   mediumpurple3 
#            207              33             164            1504              42 
#     orangered4   paleturquoise           plum1          purple             red 
#             44              77              45             416             888 
#      royalblue     saddlebrown          salmon         sienna3         skyblue 
#            162              90             343              58             103 
#       skyblue3       steelblue             tan       turquoise           white 
#             55              87             354            2220             103 
#         yellow     yellowgreen 
#           1464              57 



#############################################WGCNA: Relating consensus modules to tumour set-specific modules
##New terminal



module load legacy_lungen_modules
module load R

cd /rds/general/project/nhli-lungen-asthma/live/Saffron/EXPRESSION/CANCER2019/

R


library(ggplot2)
library(gridExtra)
library(WGCNA)

allowWGCNAThreads();
options(stringsAsFactors = FALSE);



lnames = load(file = "ADEvsSQonly/Consensus-dataInput.RData");
lnames
#[1] "multiExpr"   "Traits"      "nGenes"      "nSamples"    "setLabels"  
#[6] "shortLabels" "exprSize"  

####################### Load the results of the consensus network analysis
lnames = load(file = "ADEvsSQonly/Consensus-NetworkConstruction-man.RData");
lnames

#[1] "consMEs"      "moduleColors" "moduleLabels" "consTree" 


####################### Load the results of the tumour-only network analysis

lnames = load("ADEvsSQonly/Tumour_only_manual/Tonly-networkConstruction-stepByStep.RData")
lnames

#[1] "TUMOURMEs"          "TUMOURmoduleLabels" "TUMOURmoduleColors"
#[4] "TUMOURgeneTree"   

TUMOURMEs<-orderMEs(TUMOURMEs);


T_ModuleLabels = substring(names(TUMOURMEs), 3)
consModuleLabels = substring(names(consMEs[[1]]$data), 3)


T_Modules = T_ModuleLabels
consModules = labels2colors(as.numeric(consModuleLabels))

n_T_Mods = length(T_Modules)
nConsMods = length(consModules)

pTable = matrix(0, nrow = n_T_Mods, ncol = nConsMods);
CountTbl = matrix(0, nrow = n_T_Mods, ncol = nConsMods);

for (tmod in 1:n_T_Mods)
  for (cmod in 1:nConsMods)
  {
    T_Members = (TUMOURmoduleColors == T_Modules[tmod]);
    consMembers = (moduleColors == consModules[cmod]);
    pTable[tmod, cmod] = -log10(fisher.test(T_Members, consMembers, alternative = "greater")$p.value);
    CountTbl[tmod, cmod] = sum(TUMOURmoduleColors == T_Modules[tmod] & moduleColors ==
                      consModules[cmod])
  }



pTable[is.infinite(pTable)] = 1.3*max(pTable[is.finite(pTable)]);
pTable[pTable>50 ] = 50 ;
# Marginal counts (really module sizes)
T_ModTotals = apply(CountTbl, 1, sum)
consModTotals = apply(CountTbl, 2, sum)

pdf(file = "ADEvsSQonly/Tumour_only_manual/ConsensusVsTumourModules.pdf", wi = 35, he = 10);
par(mfrow=c(1,1));
par(cex = 1.0);
par(mar=c(12, 20, 2.7, 0.5)+0.3);
# Use function labeledHeatmap to produce the color-coded table with all the trimmings
labeledHeatmap(Matrix = pTable,
               xLabels = paste(" ", consModules),
               yLabels = paste(" ", T_Modules),
               colorLabels = TRUE,
               xSymbols = paste("Cons ", consModules, ": ", consModTotals, sep=""),
               ySymbols = paste("Tumour ", T_Modules, ": ", T_ModTotals, sep=""),
               textMatrix = CountTbl,
               colors = blueWhiteRed(100)[50:100],
               main = "Correspondence of Tumour set-specific and Tumour-Normal consensus modules",
               cex.text = 1.0, cex.lab = 1.0, setStdMargins = FALSE);
dev.off();





#############################################WGCNA: Normal-only
##In a new terminal


module load legacy_lungen_modules
module load R

cd /rds/general/project/nhli-lungen-asthma/live/Saffron/EXPRESSION/CANCER2019/

R


library(ggplot2)
library(gridExtra)
library(WGCNA)

allowWGCNAThreads();
options(stringsAsFactors = FALSE);


#######################Specify normal data

load("ADEvsSQonly/Consensus-dataInput.RData")


NdatExpr<-multiExpr[[2]]$data
NdatTraits<-Traits[[2]]$data

table(rownames(NdatExpr)==rownames(NdatTraits))
rm(exprSize,multiExpr,nGenes,nSamples,setLabels,shortLabels,Traits)


#######################Normal: Soft thresholding


softPower = 5;
adjacency = adjacency(NdatExpr, power = softPower);

#######################Normal: TOM
TOM = TOMsimilarity(adjacency);

#..connectivity..
#..matrix multiplication..
#..normalization..
#..done.

dissTOM = 1-TOM

save(list=ls(),file="ADEvsSQonly/Normal_only_manual/Normal_only_manual_WGCNA_analysis.Rdata")




#############################################Normal: Hierarchical clustering and network identification


geneTree = hclust(as.dist(dissTOM), method = "average");

pdf(file = "ADEvsSQonly/Normal_only_manual/N_SampleClustering.pdf", width = 16, height = 12);
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity - Normal only",
     labels = FALSE, hang = 0.04);
dev.off()



minModuleSize = 30;
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
                deepSplit = 2, cutHeight = 0.995, pamRespectsDendro = FALSE,
                minClusterSize = minModuleSize);
table(dynamicMods)

#dynamicMods
#   0    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15 
# 567 2284 1857 1834 1147  635  624  562  551  516  438  410  347  331  292  277 
#  16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31 
# 269  266  259  245  244  241  237  235  229  219  219  205  203  195  187  177 
#  32   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47 
# 168  164  152  140  134  133  122  122  117  110  104   91   89   85   79   77 
#  48   49   50   51   52   53   54   55   56   57   58 
#  58   58   58   55   49   49   48   40   40   39   34 


dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)

#dynamicColors
#        bisque4           black            blue           brown          brown4 
#             77             562            1857            1834              79 
#           cyan       darkgreen        darkgrey     darkmagenta  darkolivegreen 
#            292             237             229             152             164 
#     darkorange     darkorange2         darkred   darkslateblue   darkturquoise 
#            219              85             241              58             235 
#    floralwhite           green     greenyellow            grey          grey60 
#             89             635             410             567             266 
#      honeydew1           ivory  lavenderblush3       lightcyan      lightcyan1 
#             34              91              39             269             104 
#     lightgreen      lightpink4 lightsteelblue1     lightyellow         magenta 
#            259              40             110             245             516 
#         maroon   mediumpurple3    midnightblue    navajowhite2          orange 
#             40             117             277              48             219 
#     orangered4   paleturquoise  palevioletred3            pink           plum1 
#            122             177              49             551             122 
#          plum2          purple             red       royalblue     saddlebrown 
#             58             438             624             244             195 
#         salmon         salmon4         sienna3         skyblue        skyblue3 
#            331              49             140             203             133 
#      steelblue             tan        thistle1        thistle2       turquoise 
#            187             347              55              58            2284 
#         violet           white          yellow     yellowgreen 
#            168             205            1147             134 


pdf(file = "ADEvsSQonly/Normal_only_manual/Nonly_dendrogram.pdf", width = 8, height = 6);

plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colours")
dev.off()

MEList = moduleEigengenes(NdatExpr, colors = dynamicColors)
MEs = MEList$eigengenes
MEDiss = 1-cor(MEs);
METree = hclust(as.dist(MEDiss), method = "average");

pdf(file = "ADEvsSQonly/Normal_only_manual/Nonly_clustering_of_module_eigengenes.pdf", width = 14, height = 6);
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")
dev.off()


MEDissThres = 0.25

pdf(file = "ADEvsSQonly/Normal_only_manual/Nonly_clustering_of_module_eigengenes_with_cutline.pdf", width = 14, height = 6);
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")+abline(h=MEDissThres, col = "red")
dev.off()


merge = mergeCloseModules(NdatExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)


# mergeCloseModules: Merging modules whose distance is less than 0.25
#   multiSetMEs: Calculating module MEs.
#     Working on set 1 ...
#     moduleEigengenes: Calculating 59 module eigengenes in given set.
#   multiSetMEs: Calculating module MEs.
#     Working on set 1 ...
#     moduleEigengenes: Calculating 43 module eigengenes in given set.
#   multiSetMEs: Calculating module MEs.
#     Working on set 1 ...
#     moduleEigengenes: Calculating 40 module eigengenes in given set.
#   Calculating new MEs...
#   multiSetMEs: Calculating module MEs.
#     Working on set 1 ...
#     moduleEigengenes: Calculating 40 module eigengenes in given set.



mergedColors = merge$colors;
mergedMEs = merge$newMEs;



pdf(file = "ADEvsSQonly/Normal_only_manual/Nonly_dendrogram_after_merging_modules.pdf", width = 14, height = 6);

plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
dev.off()


moduleColors = mergedColors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;


##Rename to avoid overlap

NORMALMEs<-MEs
NORMALmoduleLabels<-moduleLabels
NORMALmoduleColors<-moduleColors
NORMALgeneTree<-geneTree

## Save module colours and labels for subsequent use 
save(NORMALMEs, NORMALmoduleLabels, NORMALmoduleColors, NORMALgeneTree, file = "ADEvsSQonly/Normal_only_manual/Nonly-networkConstruction-stepByStep.RData")


#######################Normal: Relating normal-only modules to external trait information

NdatTraits2<-NdatTraits[,c(2,3,4,5,6,7,8,9,10,11,17,18)]
C_XLABELS2<-c("Lymph Invasion", "Vasculature Invasion", "Pleural Invasion","Cancer Stage","Degree of Pleural Involvement","Sex","Age (years)","PYH","BMI","FEV1","LUAD","LUSC")

cbind(names(NdatTraits2),C_XLABELS2)
#                         C_XLABELS2                     
# [1,] "lymph_invasion"   "Lymph Invasion"               
# [2,] "AN_vascinvasion"  "Vasculature Invasion"         
# [3,] "pleural_invasion" "Pleural Invasion"             
# [4,] "stage_x"          "Cancer Stage"                 
# [5,] "pleural_stage"    "Degree of Pleural Involvement"
# [6,] "gender"           "Sex"                          
# [7,] "age_op"           "Age (years)"                  
# [8,] "PYH"              "PYH"                          
# [9,] "BMI"              "BMI"                          
#[10,] "FEV1"             "FEV1"                         
#[11,] "Adenocarcinoma"   "LUAD"                         
#[12,] "SCC"              "LUSC"            


#######Reassign invasion phenotypes for directionality
#Historically 1==YES, 2==NO
#Recode to 0==NO, 1==YES

NdatTraits2$lymph_invasion<-gsub("2","0", NdatTraits2$lymph_invasion)
NdatTraits2$pleural_invasion<-gsub("2","0", NdatTraits2$pleural_invasion)
NdatTraits2$AN_vascinvasion<-gsub("2","0", NdatTraits2$AN_vascinvasion)




##Relate Nonly modules to clinical traits

# Define numbers of genes and samples
nGenes = ncol(NdatExpr);
nSamples = nrow(NdatExpr);
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(NdatExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)


TestBicor = bicorAndPvalue(MEs, NdatTraits2, use = "p", alternative="two.sided",robustY=FALSE, maxPOutliers=0.05);


BI_Pval<-TestBicor$p
BI_Cor<-TestBicor$bicor
BI_nObs<-TestBicor$nObs
BI_t<-TestBicor$t
BI_Z<-TestBicor$Z





#Plot results
pdf(file = "ADEvsSQonly/Normal_only_manual/Nonly_ModuleTraitRelationships_BICOR_InvasionPhenosRecoded.pdf", wi = 10, he = 12);
textMatrix =  paste(signif(BI_Cor, 2), "\n(",
                           signif(BI_Pval, 1), ")", sep = "");
dim(textMatrix) = dim(BI_Cor)
par(mar = c(9, 11, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = BI_Cor,
               xLabels = C_XLABELS2,
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships in histologically normal samples"))


dev.off()




survival = as.data.frame(NdatTraits$mths_survival_till_death);
names(survival) = "Survival"
modNames = substring(names(MEs), 3)

geneModuleMembership = as.data.frame(cor(NdatExpr, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));

names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");

geneTraitSignificance = as.data.frame(cor(NdatExpr, survival, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));

names(geneTraitSignificance) = paste("GS.", names(survival), sep="");
names(GSPvalue) = paste("p.GS.", names(survival), sep="");


annotTC <- read.table("/rds/general/project/nhli-lungen-asthma/live/Saffron/EXPRESSION/ANNOTATION/HuGene-1_1-st-v1/HuGene-1_1-st-v1.na36.hg19.transcript.csv",sep=",",header=T)


annotTC$TCID<-paste("TC",annotTC$transcript_cluster_id,sep="")
probes = names(NdatExpr)
probes2annot = match(probes, annotTC$TCID)
## The following is the number or probes without annotation:
sum(is.na(probes2annot))
#[1] 0



geneInfo0 = data.frame(Probe = probes,
                       GeneAssignment = annotTC$gene_assignment[probes2annot],
                       mRNAassignment=annotTC$mrna_assignment[probes2annot],
                       Chr = annotTC$seqname[probes2annot],
                       moduleColor = moduleColors,
                       geneTraitSignificance,
                       GSPvalue)
modOrder = order(-abs(cor(MEs, survival, use = "p")));
for (mod in 1:ncol(geneModuleMembership))
{
  oldNames = names(geneInfo0)
  geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]], 
                         MMPvalue[, modOrder[mod]]);
  names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
                       paste("p.MM.", modNames[modOrder[mod]], sep=""))
}
geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.Survival));
geneInfo = geneInfo0[geneOrder, ]


write.csv(geneInfo, file = "ADEvsSQonly/Normal_only_manual/Nonly_geneInfo.csv",quote=TRUE)



save(list=ls(),file="ADEvsSQonly/Normal_only_manual/Normal_only_manual_WGCNA_analysis.Rdata")



table(moduleColors)
#moduleColors
#       bisque4          black           cyan       darkgrey    darkmagenta 
#            77           2925            939            229            285 
#darkolivegreen    darkorange2        darkred  darkslateblue    floralwhite 
#           383           4756            241             58             89 
#          grey         grey60      honeydew1          ivory lavenderblush3 
#           567            266             34             91             39 
#     lightcyan     lightcyan1     lightgreen     lightpink4    lightyellow 
#           717            104            259             40            450 
#       magenta         maroon   midnightblue   navajowhite2         orange 
#           760             40            277            170            219 
# paleturquoise palevioletred3           pink          plum1          plum2 
#           345             49            551            122            405 
#        purple            red    saddlebrown        salmon4        skyblue 
#           438            764            195             49            203 
#     steelblue       thistle1       thistle2         yellow    yellowgreen 
#           187             55             58           1147            134 



#############################################WGCNA: Relating consensus modules to normal set-specific modules
##In a new terminal



cd /rds/general/project/nhli-lungen-asthma/live/Saffron/EXPRESSION/CANCER2019/

R


library(WGCNA)
options(stringsAsFactors = FALSE);



lnames = load(file = "ADEvsSQonly/Consensus-dataInput.RData");
lnames

#[1] "multiExpr"   "Traits"      "nGenes"      "nSamples"    "setLabels"  
#[6] "shortLabels" "exprSize"   

####################### Load the results of the consensus network analysis

lnames = load(file = "ADEvsSQonly/Consensus-NetworkConstruction-man.RData");
lnames

#[1] "consMEs"      "moduleColors" "moduleLabels" "consTree"  


####################### Load the results of the normal-only network analysis

lnames = load("ADEvsSQonly/Normal_only_manual/Nonly-networkConstruction-stepByStep.RData")
lnames

#[1] "NORMALMEs"          "NORMALmoduleLabels" "NORMALmoduleColors"
#[4] "NORMALgeneTree" 

NORMALMEs<-orderMEs(NORMALMEs);


N_ModuleLabels = substring(names(NORMALMEs), 3)
consModuleLabels = substring(names(consMEs[[2]]$data), 3)


N_Modules = N_ModuleLabels
consModules = labels2colors(as.numeric(consModuleLabels))

n_N_Mods = length(N_Modules)
nConsMods = length(consModules)

pTable = matrix(0, nrow = n_N_Mods, ncol = nConsMods);
CountTbl = matrix(0, nrow = n_N_Mods, ncol = nConsMods);

for (nmod in 1:n_N_Mods)
  for (cmod in 1:nConsMods)
  {
    N_Members = (NORMALmoduleColors == N_Modules[nmod]);
    consMembers = (moduleColors == consModules[cmod]);
    pTable[nmod, cmod] = -log10(fisher.test(N_Members, consMembers, alternative = "greater")$p.value);
    CountTbl[nmod, cmod] = sum(NORMALmoduleColors == N_Modules[nmod] & moduleColors ==
                      consModules[cmod])
  }







pTable[is.infinite(pTable)] = 1.3*max(pTable[is.finite(pTable)]);
pTable[pTable>50 ] = 50 ;
N_ModTotals = apply(CountTbl, 1, sum)
consModTotals = apply(CountTbl, 2, sum)

pdf(file = "ADEvsSQonly/Normal_only_manual/ConsensusVsNormalModules.pdf", wi = 35, he = 10);
par(mfrow=c(1,1));
par(cex = 1.0);
par(mar=c(12, 20, 2.7, 0.5)+0.3);
# Use function labeledHeatmap to produce the color-coded table with all the trimmings
labeledHeatmap(Matrix = pTable,
               xLabels = paste(" ", consModules),
               yLabels = paste(" ", N_Modules),
               colorLabels = TRUE,
               xSymbols = paste("Cons ", consModules, ": ", consModTotals, sep=""),
               ySymbols = paste("Normal ", N_Modules, ": ", N_ModTotals, sep=""),
               textMatrix = CountTbl,
               colors = blueWhiteRed(100)[50:100],
               main = "Correspondence of 'Normal' set-specific and Tumour-Normal consensus modules",
               cex.text = 1.0, cex.lab = 1.0, setStdMargins = FALSE);
dev.off();



